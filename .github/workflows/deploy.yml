name: Deploy app to EC2

on:
  push:
    branches:
      - main
    paths:
      - 'app/**'  # app 폴더 변경시에만 실행
      - '.github/workflows/deploy.yml'  # 워크플로우 파일 변경시에도 실행
  workflow_dispatch:  # 수동 배포 허용

jobs:
  deploy:
    name: Deploy Backend to EC2
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: app  # 모든 run 명령은 app/ 디렉토리에서 실행

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Setup SSH
        working-directory: .  # SSH 설정은 루트에서 실행
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER || 'ubuntu' }}
        run: |
          # 절대 경로 사용
          SSH_DIR="$HOME/.ssh"
          SSH_KEY="$SSH_DIR/deploy_key"

          # 환경 변수 설정 및 검증
          EC2_HOST="${{ secrets.EC2_HOST }}"
          EC2_USER="${{ secrets.EC2_USER || 'ubuntu' }}"

          # 변수 검증
          if [ -z "$EC2_HOST" ]; then
            echo "❌ EC2_HOST가 설정되지 않았습니다."
            exit 1
          fi

          if [ -z "$EC2_USER" ]; then
            echo "⚠️ EC2_USER가 설정되지 않아 기본값 'ubuntu'를 사용합니다."
            EC2_USER="ubuntu"
          fi

          # 사용자 이름에 잘못된 문자가 있는지 확인
          if echo "$EC2_USER" | grep -qE '[^a-zA-Z0-9_-]'; then
            echo "❌ EC2_USER에 잘못된 문자가 포함되어 있습니다: $EC2_USER"
            echo "💡 사용자 이름은 영문자, 숫자, 하이픈(-), 언더스코어(_)만 사용할 수 있습니다."
            exit 1
          fi

          echo "📌 EC2_HOST: $EC2_HOST"
          echo "📌 EC2_USER: $EC2_USER"

          # .ssh 디렉토리 생성 (이미 파일로 존재하면 제거)
          if [ -f "$SSH_DIR" ]; then
            rm -f "$SSH_DIR"
          fi
          mkdir -p "$SSH_DIR"
          chmod 700 "$SSH_DIR"

          # SSH 키 파일 생성 (개행 문자 처리)
          # secrets의 내용을 그대로 저장 (base64나 다른 인코딩이 아닌 원본)
          echo "${{ secrets.EC2_SSH_KEY }}" > "$SSH_KEY"
          chmod 600 "$SSH_KEY"

          # SSH 키 파일 형식 확인
          echo "📋 SSH 키 파일 확인:"
          if grep -q "BEGIN.*PRIVATE KEY" "$SSH_KEY"; then
            echo "✅ SSH 키 형식 확인됨 (PRIVATE KEY)"
            # 첫 줄과 마지막 줄만 표시
            head -n 1 "$SSH_KEY"
            tail -n 1 "$SSH_KEY"
          else
            echo "⚠️ SSH 키 형식이 예상과 다릅니다"
            echo "첫 50자: $(head -c 50 "$SSH_KEY")"
          fi

          # 파일 크기 확인
          echo "📏 SSH 키 파일 크기: $(wc -c < "$SSH_KEY") bytes"

          # known_hosts 파일 생성 및 EC2 호스트 추가
          touch "$SSH_DIR/known_hosts"
          chmod 600 "$SSH_DIR/known_hosts"
          ssh-keyscan -H "$EC2_HOST" >> "$SSH_DIR/known_hosts" 2>/dev/null || true

          # SSH config 파일 생성
          cat > "$SSH_DIR/config" << EOF
          Host ec2-deploy
            HostName ${EC2_HOST}
            User ${EC2_USER}
            IdentityFile ${SSH_KEY}
            StrictHostKeyChecking no
            UserKnownHostsFile ${SSH_DIR}/known_hosts
          EOF
          chmod 600 "$SSH_DIR/config"

          # SSH 설정 확인
          echo "📁 SSH 디렉토리 내용:"
          ls -la "$SSH_DIR/"

          # SSH 연결 테스트
          echo "🔍 SSH 연결 테스트..."
          ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "${EC2_USER}@${EC2_HOST}" "echo 'SSH 연결 성공!'" || {
            echo "⚠️ SSH 연결 테스트 실패 (계속 진행)"
          }

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt  # app/requirements.txt

      - name: Deploy to EC2
        working-directory: .  # rsync는 루트에서 app 폴더를 대상으로
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER || 'ubuntu' }}
        run: |
          # 절대 경로 사용
          SSH_KEY="$HOME/.ssh/deploy_key"

          # 환경 변수 설정 및 검증
          EC2_HOST="${{ secrets.EC2_HOST }}"
          EC2_USER="${{ secrets.EC2_USER || 'ubuntu' }}"

          # 변수 검증
          if [ -z "$EC2_HOST" ]; then
            echo "❌ EC2_HOST가 설정되지 않았습니다."
            exit 1
          fi

          if [ -z "$EC2_USER" ]; then
            echo "⚠️ EC2_USER가 설정되지 않아 기본값 'ubuntu'를 사용합니다."
            EC2_USER="ubuntu"
          fi

          # 사용자 이름에 잘못된 문자가 있는지 확인
          if echo "$EC2_USER" | grep -qE '[^a-zA-Z0-9_-]'; then
            echo "❌ EC2_USER에 잘못된 문자가 포함되어 있습니다: $EC2_USER"
            echo "💡 사용자 이름은 영문자, 숫자, 하이픈(-), 언더스코어(_)만 사용할 수 있습니다."
            exit 1
          fi

          echo "📌 EC2_HOST: $EC2_HOST"
          echo "📌 EC2_USER: $EC2_USER"

          # SSH 키 파일 존재 확인
          if [ ! -f "$SSH_KEY" ]; then
            echo "❌ SSH 키 파일을 찾을 수 없습니다: $SSH_KEY"
            exit 1
          fi

          # SSH 키 권한 확인
          if [ "$(stat -c %a "$SSH_KEY" 2>/dev/null || stat -f %A "$SSH_KEY" 2>/dev/null)" != "600" ]; then
            echo "🔧 SSH 키 권한 수정 중..."
            chmod 600 "$SSH_KEY"
          fi

          # SSH 연결 테스트
          echo "🔍 SSH 연결 테스트..."
          ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            "${EC2_USER}@${EC2_HOST}" "echo 'SSH 연결 성공!'" || {
            echo "❌ SSH 연결 실패"
            echo "💡 EC2_SSH_KEY, EC2_HOST, EC2_USER 설정을 확인하세요"
            echo "💡 현재 설정:"
            echo "   - EC2_HOST: $EC2_HOST"
            echo "   - EC2_USER: $EC2_USER"
            exit 1
          }

          # app 폴더를 EC2에 동기화 (SSH 키 절대 경로 사용)
          echo "📤 app 폴더 동기화 중..."
          # app 디렉토리 구조를 유지하기 위해 app/를 rag-app/app/로 동기화
          rsync -avz -e "ssh -i $SSH_KEY -o StrictHostKeyChecking=no -o ConnectTimeout=10" \
            --exclude='.git' --exclude='__pycache__' --exclude='*.pyc' \
            --exclude='venv' --exclude='.env' --exclude='*.pyc' \
            app/ "${EC2_USER}@${EC2_HOST}:/home/ubuntu/rag-app/app/"

          # main.py를 rag-app 루트로 복사 (uvicorn 실행을 위해)
          echo "📋 main.py를 루트로 복사 중..."
          ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "${EC2_USER}@${EC2_HOST}" \
            "cp /home/ubuntu/rag-app/app/main.py /home/ubuntu/rag-app/main.py 2>/dev/null || true"

          # EC2에서 배포 실행
          ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "${EC2_USER}@${EC2_HOST}" << ENDSSH
            set -e

            echo "🚀 배포 시작..."

            # 배포 디렉토리 확인 및 생성
            DEPLOY_DIR="/home/ubuntu/rag-app"

            # 변수 검증 (명시적으로 확인)
            if [ -z "\${DEPLOY_DIR}" ] || [ "\${DEPLOY_DIR}" = "" ]; then
              echo "❌ DEPLOY_DIR 변수가 설정되지 않았습니다."
              echo "💡 디버깅: DEPLOY_DIR 값 확인 중..."
              echo "   DEPLOY_DIR='\${DEPLOY_DIR}'"
              exit 1
            fi

            echo "📌 DEPLOY_DIR: \${DEPLOY_DIR}"

            # 디렉토리 생성
            if [ ! -d "\${DEPLOY_DIR}" ]; then
              echo "📁 배포 디렉토리 생성 중: \${DEPLOY_DIR}"
              mkdir -p "\${DEPLOY_DIR}" || {
                echo "❌ 디렉토리 생성 실패: \${DEPLOY_DIR}"
                exit 1
              }
              # 권한 설정 (가능한 경우)
              chown -R ubuntu:ubuntu "\${DEPLOY_DIR}" 2>/dev/null || sudo chown -R ubuntu:ubuntu "\${DEPLOY_DIR}" 2>/dev/null || true
              echo "✅ 배포 디렉토리 생성 완료"
            else
              echo "✅ 배포 디렉토리 이미 존재함: \${DEPLOY_DIR}"
            fi

            # 환경 변수 설정 (.env 파일 생성/업데이트)
            echo "🔐 환경 변수 설정 중..."
            ENV_FILE="\${DEPLOY_DIR}/.env"

            # ENV_FILE 변수 검증
            if [ -z "\${ENV_FILE}" ]; then
              echo "❌ ENV_FILE 변수가 설정되지 않았습니다."
              exit 1
            fi

            echo "📌 ENV_FILE 경로: \${ENV_FILE}"

            # .env 파일이 없으면 생성
            if [ ! -f "\${ENV_FILE}" ]; then
              echo "📝 .env 파일 생성 중..."
              touch "\${ENV_FILE}"
              chmod 600 "\${ENV_FILE}"
              echo "✅ .env 파일 생성 완료"
            else
              echo "✅ 기존 .env 파일 확인됨"
            fi

            # .env 파일 완전히 새로 작성 (기존 내용 완전히 제거)
            echo "📝 .env 파일 완전히 재작성 중..."
            ENV_BACKUP="\${ENV_FILE}.bak"
            if [ -f "\${ENV_FILE}" ]; then
              cp "\${ENV_FILE}" "\${ENV_BACKUP}"
              echo "📋 기존 .env 파일 백업: \${ENV_BACKUP}"
            fi

            # 기존 .env 파일 완전히 삭제 후 새로 생성
            rm -f "\${ENV_FILE}"
            touch "\${ENV_FILE}"
            chmod 600 "\${ENV_FILE}"

            # 환경 변수 카운터
            ENV_COUNT=0

            # OpenAI API 키 설정 (GitHub Secrets에서)
            if [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
              printf 'OPENAI_API_KEY=%s\n' "${{ secrets.OPENAI_API_KEY }}" >> "\${ENV_FILE}"
              ENV_COUNT=$((ENV_COUNT + 1))
              echo "✅ OPENAI_API_KEY 추가됨"
            else
              echo "⚠️ OPENAI_API_KEY가 GitHub Secrets에 설정되지 않았습니다."
            fi

            # DATABASE_URL 설정 (GitHub Secrets에서)
            if [ -n "${{ secrets.DATABASE_URL }}" ]; then
              # DATABASE_URL은 특수문자가 많으므로 printf로 안전하게 작성
              # 기존 DATABASE_URL 라인 제거 (중복 방지)
              grep -v "^DATABASE_URL=" "\${ENV_FILE}" > "\${ENV_FILE}.tmp" 2>/dev/null || true
              mv "\${ENV_FILE}.tmp" "\${ENV_FILE}" 2>/dev/null || true
              # 새로 추가
              printf 'DATABASE_URL=%s\n' "${{ secrets.DATABASE_URL }}" >> "\${ENV_FILE}"
              ENV_COUNT=$((ENV_COUNT + 1))
              echo "✅ DATABASE_URL 추가됨"
            else
              echo "⚠️ DATABASE_URL이 GitHub Secrets에 설정되지 않았습니다."
            fi

            # LLM_PROVIDER 설정 (GitHub Secrets에서)
            if [ -n "${{ secrets.LLM_PROVIDER }}" ]; then
              printf 'LLM_PROVIDER=%s\n' "${{ secrets.LLM_PROVIDER }}" >> "\${ENV_FILE}"
              ENV_COUNT=$((ENV_COUNT + 1))
              echo "✅ LLM_PROVIDER 추가됨"
            else
              echo "⚠️ LLM_PROVIDER가 GitHub Secrets에 설정되지 않았습니다."
            fi

            # .env 파일 검증
            echo "🔍 .env 파일 검증 중..."
            echo "📊 환경 변수 개수: \${ENV_COUNT}"

            # DATABASE_URL 중복 확인
            DATABASE_URL_COUNT=$(grep -c "^DATABASE_URL=" "\${ENV_FILE}" 2>/dev/null || echo "0")
            if [ "\${DATABASE_URL_COUNT}" -gt 1 ]; then
              echo "❌ DATABASE_URL이 중복되어 있습니다! (\${DATABASE_URL_COUNT}개)"
              echo "💡 .env 파일 내용:"
              cat "\${ENV_FILE}"
              echo "💡 중복 제거 중..."
              # 첫 번째 DATABASE_URL만 유지
              awk '!seen[\$0]++ || !/^DATABASE_URL=/' "\${ENV_FILE}" > "\${ENV_FILE}.tmp"
              mv "\${ENV_FILE}.tmp" "\${ENV_FILE}"
              echo "✅ 중복 제거 완료"
            fi

            # .env 파일 내용 확인 (디버깅용, 값은 마스킹)
            echo "📋 .env 파일 구조 확인 (값은 마스킹):"
            sed 's/=.*/=***/' "\${ENV_FILE}" || true
            echo "📋 .env 파일 라인 수:"
            wc -l "\${ENV_FILE}" || echo "0"

            # .env 파일 권한 확인
            chmod 600 "\${ENV_FILE}"
            echo "✅ 환경 변수 설정 완료"

            # 배포 디렉토리로 이동
            cd "\${DEPLOY_DIR}" || {
              echo "❌ 배포 디렉토리를 찾을 수 없습니다: \${DEPLOY_DIR}"
              exit 1
            }

            # Python 및 venv 패키지 확인 및 설치
            echo "🔍 Python 환경 확인 중..."
            if ! command -v python3 &> /dev/null; then
              echo "❌ Python3가 설치되어 있지 않습니다."
              exit 1
            fi

            PYTHON_FULL_VERSION=$(python3 --version | cut -d' ' -f2)
            PYTHON_MAJOR_MINOR=$(echo "$PYTHON_FULL_VERSION" | cut -d'.' -f1,2)
            PYTHON_MAJOR=$(echo "$PYTHON_FULL_VERSION" | cut -d'.' -f1)
            PYTHON_MINOR=$(echo "$PYTHON_FULL_VERSION" | cut -d'.' -f2)

            echo "📌 Python 버전: $PYTHON_FULL_VERSION"
            echo "📌 Python 버전 (Major.Minor): $PYTHON_MAJOR_MINOR"

            # Python 버전에 맞는 venv 패키지 설치
            echo "📦 Python venv 패키지 확인 및 설치 중..."
            sudo apt-get update -qq

            # Python 버전별 venv 패키지 설치 시도
            VENV_PACKAGE="python${PYTHON_MAJOR}.${PYTHON_MINOR}-venv"
            if apt-cache show "$VENV_PACKAGE" &>/dev/null; then
              echo "📦 $VENV_PACKAGE 패키지 설치 중..."
              sudo apt-get install -y "$VENV_PACKAGE" python3-pip || {
                echo "⚠️ $VENV_PACKAGE 설치 실패, python3-venv 시도..."
                sudo apt-get install -y python3-venv python3-pip
              }
            else
              echo "📦 python3-venv 패키지 설치 중..."
              sudo apt-get install -y python3-venv python3-pip
            fi

            # venv 모듈 확인
            if ! python3 -c "import venv" 2>/dev/null; then
              echo "❌ venv 모듈을 찾을 수 없습니다."
              echo "💡 설치된 Python venv 패키지 확인 중..."
              dpkg -l | grep -i python.*venv || echo "venv 패키지 없음"
              exit 1
            fi
            echo "✅ venv 모듈 확인됨"

            # 현재 작업 디렉토리 확인
            echo "📌 현재 작업 디렉토리: $(pwd)"
            echo "📌 DEPLOY_DIR: \${DEPLOY_DIR}"

            # Python 가상환경 설정 (불완전한 venv 체크 및 재생성)
            if [ -d "venv" ] && [ -f "venv/bin/activate" ] && [ -f "venv/bin/python3" ]; then
              echo "✅ 기존 가상환경 확인됨"
            else
              if [ -d "venv" ]; then
                echo "⚠️ 불완전한 가상환경 감지, 재생성 중..."
                rm -rf venv
              fi

              echo "📦 Python 가상환경 생성 중..."
              echo "📌 생성 위치: $(pwd)/venv"

              # venv 생성 시도
              if ! python3 -m venv venv 2>&1; then
                echo "❌ 가상환경 생성 실패, 상세 오류 확인 중..."
                python3 -m venv venv 2>&1 || {
                  echo "💡 ensurepip 확인 중..."
                  python3 -c "import ensurepip; print('ensurepip 사용 가능')" 2>&1 || {
                    echo "⚠️ ensurepip 없음, --without-pip 옵션으로 생성 시도..."
                    python3 -m venv --without-pip venv
                    if [ -f "venv/bin/python3" ]; then
                      echo "📦 pip 설치 중..."
                      venv/bin/python3 -m ensurepip --upgrade || {
                        curl -sS https://bootstrap.pypa.io/get-pip.py | venv/bin/python3
                      }
                    fi
                  }
                }
              fi

              # venv 생성 확인 (더 상세하게)
              echo "🔍 가상환경 생성 확인 중..."
              if [ ! -d "venv" ]; then
                echo "❌ venv 디렉토리가 생성되지 않았습니다."
                echo "💡 현재 디렉토리 내용:"
                ls -la
                exit 1
              fi

              if [ ! -f "venv/bin/activate" ]; then
                echo "❌ venv/bin/activate 파일이 없습니다."
                echo "💡 venv 디렉토리 내용:"
                ls -la venv/ 2>/dev/null || echo "venv 디렉토리 없음"
                echo "💡 venv/bin 디렉토리 내용:"
                ls -la venv/bin/ 2>/dev/null || echo "venv/bin 디렉토리 없음"
                exit 1
              fi

              if [ ! -f "venv/bin/python3" ]; then
                echo "❌ venv/bin/python3 파일이 없습니다."
                echo "💡 venv/bin 디렉토리 내용:"
                ls -la venv/bin/ 2>/dev/null || echo "venv/bin 디렉토리 없음"
                exit 1
              fi

              echo "✅ 가상환경 생성 완료"
              echo "📋 venv 구조 확인:"
              ls -la venv/bin/activate
              ls -la venv/bin/python3
            fi

            # 가상환경 활성화 전 최종 확인
            echo "🔄 가상환경 활성화 준비 중..."
            if [ ! -d "venv" ]; then
              echo "❌ venv 디렉토리가 존재하지 않습니다."
              echo "💡 현재 디렉토리: $(pwd)"
              exit 1
            fi

            if [ ! -f "venv/bin/activate" ]; then
              echo "❌ venv/bin/activate 파일이 존재하지 않습니다."
              echo "💡 venv 디렉토리 내용:"
              ls -la venv/ 2>/dev/null || echo "venv 디렉토리 없음"
              exit 1
            fi

            # 가상환경 활성화
            echo "🔄 가상환경 활성화 중..."
            source venv/bin/activate || {
              echo "❌ source 명령 실패"
              echo "💡 activate 스크립트 내용 확인:"
              head -n 5 venv/bin/activate 2>/dev/null || echo "activate 파일을 읽을 수 없음"
              exit 1
            }

            # 가상환경 활성화 확인
            if [ -z "\${VIRTUAL_ENV}" ]; then
              echo "❌ 가상환경 활성화 실패"
              echo "💡 디버깅 정보:"
              echo "   - 현재 디렉토리: $(pwd)"
              echo "   - venv 디렉토리 존재: $([ -d "venv" ] && echo "예" || echo "아니오")"
              echo "   - activate 스크립트 존재: $([ -f "venv/bin/activate" ] && echo "예" || echo "아니오")"
              ls -la venv/bin/activate 2>/dev/null || echo "   - activate 파일을 찾을 수 없음"
              exit 1
            fi
            echo "✅ 가상환경 활성화됨: $VIRTUAL_ENV"
            echo "📌 Python 경로: $(which python)"
            echo "📌 pip 경로: $(which pip)"

            # 디스크 공간 확인 및 정리
            echo "💾 디스크 공간 확인 중..."
            df -h /

            # 항상 정리 작업 수행 (디스크 공간 확보)
            echo "🧹 디스크 정리 중..."
            # pip 캐시 정리
            pip cache purge 2>/dev/null || true
            # apt 캐시 정리
            sudo apt-get clean 2>/dev/null || true
            sudo apt-get autoremove -y 2>/dev/null || true
            # 임시 파일 정리
            sudo rm -rf /tmp/* 2>/dev/null || true
            sudo rm -rf /var/tmp/* 2>/dev/null || true
            # 로그 파일 정리 (오래된 것만)
            sudo journalctl --vacuum-time=1d 2>/dev/null || true

            echo "✅ 정리 완료"
            df -h /

            # 의존성 설치
            echo "📦 의존성 설치 중..."
            pip install --upgrade pip

            # OpenAI API만 사용하므로 torch 등 로컬 LLM 패키지는 불필요
            # requirements.txt의 패키지만 설치
            echo "📦 패키지 설치 중..."
            pip install --no-cache-dir -r requirements.txt

            # EC2 내부 방화벽 확인 및 비활성화
            echo "🔥 방화벽 상태 확인 중..."
            if command -v ufw &> /dev/null; then
              if sudo ufw status | grep -q "Status: active"; then
                echo "⚠️ ufw가 활성화되어 있습니다. 포트 8000 허용 중..."
                sudo ufw allow 8000/tcp
                sudo ufw reload
              else
                echo "✅ ufw 비활성화됨"
              fi
            fi

            # systemd 서비스 확인 및 설정
            echo "🔍 systemd 서비스 확인 중..."

            # 서비스 파일이 있으면 백업
            if [ -f /etc/systemd/system/fastapi-rag.service ]; then
              echo "📋 기존 서비스 파일 백업 중..."
              sudo cp /etc/systemd/system/fastapi-rag.service /etc/systemd/system/fastapi-rag.service.bak
            fi

            echo "📝 systemd 서비스 파일 생성 중..."
            printf '%s\n' \
              '[Unit]' \
              'Description=FastAPI RAG Backend' \
              'After=network.target' \
              '' \
              '[Service]' \
              'Type=simple' \
              'User=ubuntu' \
              'Group=ubuntu' \
              'WorkingDirectory=/home/ubuntu/rag-app' \
              'Environment="PATH=/home/ubuntu/rag-app/venv/bin:/usr/local/bin:/usr/bin:/bin"' \
              'Environment="PYTHONPATH=/home/ubuntu/rag-app"' \
              'EnvironmentFile=-/home/ubuntu/rag-app/.env' \
              'ExecStart=/home/ubuntu/rag-app/venv/bin/python -m uvicorn app.main:app --host 0.0.0.0 --port 8000' \
              'Restart=always' \
              'RestartSec=10' \
              'StandardOutput=journal' \
              'StandardError=journal' \
              '' \
              '[Install]' \
              'WantedBy=multi-user.target' | sudo tee /etc/systemd/system/fastapi-rag.service > /dev/null

            # 서비스 파일 권한 확인
            sudo chmod 644 /etc/systemd/system/fastapi-rag.service
            echo "✅ 서비스 파일 생성 완료"

            # 서비스 파일 내용 확인
            echo "📋 생성된 서비스 파일 내용:"
            sudo cat /etc/systemd/system/fastapi-rag.service

            # systemd 재로드 및 활성화
            echo "🔄 systemd 재로드 중..."
            sudo systemctl daemon-reload
            sudo systemctl enable fastapi-rag

            # 서비스 재시작
            echo "🔄 FastAPI 서비스 재시작 중..."
            if sudo systemctl restart fastapi-rag; then
              echo "✅ 서비스 재시작 명령 성공"
            else
              echo "❌ 서비스 재시작 명령 실패"
            fi
            sleep 3

            # 서비스 상태 확인
            echo "📊 서비스 상태:"
            sudo systemctl status fastapi-rag --no-pager -l || true

            # 서비스가 활성화되지 않았으면 상세 로그 확인
            if ! sudo systemctl is-active --quiet fastapi-rag 2>/dev/null; then
              echo "❌ 서비스가 실행 중이 아닙니다. 상세 로그 확인 중..."
              echo "📋 systemctl status 출력:"
              sudo systemctl status fastapi-rag --no-pager -l || true
              echo ""
              echo "📋 journalctl 로그 (최근 50줄):"
              sudo journalctl -u fastapi-rag -n 50 --no-pager || true
              echo ""
              echo "📋 서비스 파일 확인:"
              sudo cat /etc/systemd/system/fastapi-rag.service || true
              echo ""
              echo "💡 수동 실행 테스트:"
              echo "   cd /home/ubuntu/rag-app"
              echo "   source venv/bin/activate"
              echo "   python -c 'import sys; print(sys.path)'"
              echo "   uvicorn main:app --host 0.0.0.0 --port 8000"
            fi

            # 포트 리스닝 확인 (ss 명령 우선 사용, netstat은 fallback)
            echo "🔍 포트 8000 리스닝 확인 중..."
            PORT_CHECKED=false
            if command -v ss &> /dev/null; then
              if sudo ss -tuln | grep -q ":8000 "; then
                echo "✅ 포트 8000이 리스닝 중입니다 (ss 명령 사용)"
                sudo ss -tuln | grep ":8000 "
                PORT_CHECKED=true
              fi
            fi

            if [ "$PORT_CHECKED" = "false" ] && command -v netstat &> /dev/null; then
              if sudo netstat -tuln | grep -q ":8000 "; then
                echo "✅ 포트 8000이 리스닝 중입니다 (netstat 명령 사용)"
                sudo netstat -tuln | grep ":8000 "
                PORT_CHECKED=true
              fi
            fi

            if [ "$PORT_CHECKED" = "false" ]; then
              echo "❌ 포트 8000이 리스닝되지 않습니다"
              echo "💡 서비스 로그 확인:"
              sudo journalctl -u fastapi-rag -n 50 --no-pager || true
            fi

            # 서비스 실행 상태 최종 확인
            echo "🔍 서비스 실행 상태 최종 확인..."
            if sudo systemctl is-active --quiet fastapi-rag 2>/dev/null; then
              echo "✅ 서비스가 실행 중입니다"
            else
              echo "❌ 서비스가 실행 중이 아닙니다!"
              echo "💡 서비스를 수동으로 시작합니다..."
              sudo systemctl start fastapi-rag
              sleep 5
              if sudo systemctl is-active --quiet fastapi-rag 2>/dev/null; then
                echo "✅ 서비스 시작 성공"
              else
                echo "❌ 서비스 시작 실패 - 로그 확인:"
                sudo journalctl -u fastapi-rag -n 50 --no-pager || true
                exit 1
              fi
            fi

            # 헬스체크
            echo "🏥 헬스체크 중..."
            sleep 5
            for i in {1..5}; do
              if curl -f http://localhost:8000/health > /dev/null 2>&1; then
                echo "✅ 백엔드 헬스체크 성공"
                break
              else
                echo "⏳ 헬스체크 재시도 중... ($i/5)"
                sleep 2
              fi
            done

            if ! curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "❌ 백엔드 헬스체크 실패"
              echo "💡 서비스 로그:"
              sudo journalctl -u fastapi-rag -n 50 --no-pager || true
              echo "💡 포트 리스닝 확인:"
              if command -v ss &> /dev/null; then
                sudo ss -tuln | grep ":8000 " || echo "포트 8000이 리스닝되지 않음 (ss 명령 사용)"
              elif command -v netstat &> /dev/null; then
                sudo netstat -tuln | grep ":8000 " || echo "포트 8000이 리스닝되지 않음 (netstat 명령 사용)"
              else
                echo "⚠️ ss와 netstat 명령이 모두 없습니다. 포트 확인 불가"
              fi
              exit 1
            fi

            # Swagger UI 접근 확인
            echo "📚 Swagger UI 접근 확인 중..."
            if curl -f http://localhost:8000/docs > /dev/null 2>&1; then
              echo "✅ Swagger UI 접근 가능"
            else
              echo "⚠️ Swagger UI 접근 실패 (하지만 헬스체크는 성공)"
            fi

            # 외부 접속 가능 여부 확인 (EC2 내부에서)
            echo "🌐 외부 접속 정보..."
            PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null || echo "확인 불가")
            echo "📌 Public IP: $PUBLIC_IP"
            if [ "$PUBLIC_IP" != "확인 불가" ]; then
              echo "✅ 외부 접속 URL:"
              echo "   - API: http://$PUBLIC_IP:8000"
              echo "   - Swagger UI: http://$PUBLIC_IP:8000/docs"
              echo "   - Health: http://$PUBLIC_IP:8000/health"
              echo ""
              echo "🔍 외부 접속 테스트 (EC2 내부에서):"
              if curl -f --max-time 5 http://$PUBLIC_IP:8000/health > /dev/null 2>&1; then
                echo "✅ 외부 IP로 접속 가능"
              else
                echo "⚠️ 외부 IP로 접속 불가 (Security Group 확인 필요)"
              fi
            fi

            echo ""
            echo "✅ 배포 완료! 서비스가 정상적으로 실행 중입니다."
          ENDSSH

      - name: Deployment Status
        run: |
          echo "✅ 배포 프로세스 완료"
          echo "백엔드: http://${{ secrets.EC2_HOST }}:8000"
          echo "API 문서: http://${{ secrets.EC2_HOST }}:8000/docs"
